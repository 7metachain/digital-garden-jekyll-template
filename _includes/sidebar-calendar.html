<div class="sidebar-section calendar-section">
  <div class="sidebar-section-title">ğŸ“… æ—¥å†</div>
  <div id="sidebar-calendar" class="calendar-widget" aria-label="Monthly calendar"></div>
</div>

<script>
  (function renderSidebarCalendar() {
    const container = document.getElementById("sidebar-calendar");
    if (!container) return;

    const state = {
      viewDate: new Date(),
      selectedDate: new Date(),
    };

    const SOLAR_TERM_NAMES = [
      "å°å¯’", "å¤§å¯’", "ç«‹æ˜¥", "é›¨æ°´", "æƒŠè›°", "æ˜¥åˆ†",
      "æ¸…æ˜", "è°·é›¨", "ç«‹å¤", "å°æ»¡", "èŠ’ç§", "å¤è‡³",
      "å°æš‘", "å¤§æš‘", "ç«‹ç§‹", "å¤„æš‘", "ç™½éœ²", "ç§‹åˆ†",
      "å¯’éœ²", "éœœé™", "ç«‹å†¬", "å°é›ª", "å¤§é›ª", "å†¬è‡³"
    ];
    const SOLAR_TERM_INFO = [
      0, 21208, 42467, 63836, 85337, 107014, 128867, 150921,
      173149, 195551, 218072, 240693, 263343, 285989, 308563,
      331033, 353350, 375494, 397447, 419210, 440795, 462224,
      483532, 504758,
    ];
    const SOLAR_TERM_BASE = Date.UTC(1900, 0, 6, 2, 5);
    const SOLAR_YEAR_MS = 31556925974.7;
    const solarTermCache = new Map();

    function computeSolarTerms(year) {
      if (solarTermCache.has(year)) return solarTermCache.get(year);
      const monthMap = {};
      SOLAR_TERM_INFO.forEach((offsetMin, idx) => {
        const ms = SOLAR_TERM_BASE + SOLAR_YEAR_MS * (year - 1900) + offsetMin * 60000;
        const d = new Date(ms);
        const m = d.getUTCMonth() + 1;
        const day = d.getUTCDate();
        if (!monthMap[m]) monthMap[m] = [];
        monthMap[m].push({ d: day, n: SOLAR_TERM_NAMES[idx] });
      });
      solarTermCache.set(year, monthMap);
      return monthMap;
    }

    const lunarPartsFormatter = new Intl.DateTimeFormat("zh-Hans-u-ca-chinese", {
      year: "numeric",
      month: "numeric",
      day: "numeric",
    });
    const lunarDayFormatter = new Intl.DateTimeFormat("zh-Hans-u-ca-chinese", {
      day: "numeric",
    });

    const chineseDigits = { 0: "ã€‡", 1: "ä¸€", 2: "äºŒ", 3: "ä¸‰", 4: "å››", 5: "äº”", 6: "å…­", 7: "ä¸ƒ", 8: "å…«", 9: "ä¹" };
    const lunarMonthNames = ["æ­£æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", "å†¬æœˆ", "è…Šæœˆ"];
    const heavenlyStems = ["ç”²", "ä¹™", "ä¸™", "ä¸", "æˆŠ", "å·±", "åºš", "è¾›", "å£¬", "ç™¸"];
    const earthlyBranches = ["å­", "ä¸‘", "å¯…", "å¯", "è¾°", "å·³", "åˆ", "æœª", "ç”³", "é…‰", "æˆŒ", "äº¥"];

    const parseLunarNumber = (value) => {
      if (value === undefined || value === null) return 0;
      const str = String(value).replace(/[^ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åå»¿å…ã€‡0-9]/g, "");
      const num = Number(str);
      if (!Number.isNaN(num)) return num;

      const map = { "ã€‡": 0, "ä¸€": 1, "äºŒ": 2, "ä¸‰": 3, "å››": 4, "äº”": 5, "å…­": 6, "ä¸ƒ": 7, "å…«": 8, "ä¹": 9, "å": 10, "å»¿": 20, "å…": 30, "ä¸‰å": 30 };
      if (map[str] !== undefined) return map[str];
      if (str.startsWith("å")) return 10 + (map[str.slice(1)] || 0);
      if (str.startsWith("å»¿")) return 20 + (map[str.slice(1)] || 0);
      if (str.startsWith("å…")) return 30 + (map[str.slice(1)] || 0);
      return 0;
    };

    const ganzhiYear = (y) => {
      const stem = heavenlyStems[(y - 4) % 10];
      const branch = earthlyBranches[(y - 4) % 12];
      return `${stem}${branch}å¹´`;
    };

    const ganzhiMonth = (y, lunarMonth) => {
      // æœˆæ”¯ä»å¯…æœˆå¼€å§‹ï¼ˆç´¢å¼•2ï¼‰ï¼Œæœˆå¹²ä»å¯…æœˆèµ·ä¾å¹´å¹²æ¨ç®—
      const branchIdx = (lunarMonth + 1) % 12;
      const yearStemIdx = (y - 4) % 10;
      const stemStartByYearStem = [2, 4, 6, 8, 0]; // ç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸ -> ä¸™æˆŠåºšå£¬ç”²
      const stemStart = stemStartByYearStem[yearStemIdx % 5];
      const stemIdx = (stemStart + (lunarMonth - 1)) % 10;
      return `${heavenlyStems[stemIdx]}${earthlyBranches[branchIdx]}æœˆ`;
    };

    const ganzhiDay = (date) => {
      // åŸºå‡†ï¼š1984-02-02 ä¸ºç”²å­æ—¥
      const base = new Date(Date.UTC(1984, 1, 2));
      const diffDays = Math.floor((date - base) / 86400000);
      const stem = heavenlyStems[(diffDays % 10 + 10) % 10];
      const branch = earthlyBranches[(diffDays % 12 + 12) % 12];
      return `${stem}${branch}æ—¥`;
    };

    const toChineseYear = (yearNumber) => {
      return String(yearNumber)
        .split("")
        .map((d) => chineseDigits[d] || d)
        .join("");
    };

    const lunarDayName = (d) => {
      const nums = ["", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"];
      if (d === 10) return "åˆå";
      if (d === 20) return "äºŒå";
      if (d === 30) return "ä¸‰å";
      if (d < 10) return `åˆ${nums[d]}`;
      if (d < 20) return `å${nums[d - 10]}`;
      if (d < 30) return `å»¿${nums[d - 20]}`;
      return String(d);
    };

    const lunarMonthName = (m) => lunarMonthNames[(m - 1 + 12) % 12] || "";

    const jianchuSlogans = {
      "å»º": "å¥è¿ä¸æ¯",
      "é™¤": "é™¤æ—§è¿æ–°",
      "æ»¡": "è‡ªæ»¡å¿—å¼‚",
      "å¹³": "å¹³å¿ƒé™æ°”",
      "å®š": "å®šå¿—å¦‚å±±",
      "æ‰§": "æ‰§å–„å›ºæ‰§",
      "ç ´": "ç ´è€Œåç«‹",
      "å±": "å±ä¸­æœ‰æœº",
      "æˆ": "æˆå·±æˆäºº",
      "æ”¶": "æ’åºæ”¶çº³",
      "å¼€": "å¼€è¾Ÿåˆ›æ–°",
      "é—­": "é—­é—¨è¯»ä¹¦",
    };

    const getLunarParts = (date) => {
      const parts = lunarPartsFormatter.formatToParts(date);
      const y = parseLunarNumber(parts.find((p) => p.type === "year")?.value) || date.getFullYear();
      const m = parseLunarNumber(parts.find((p) => p.type === "month")?.value) || date.getMonth() + 1;
      const d = parseLunarNumber(parts.find((p) => p.type === "day")?.value) || date.getDate();
      return { y, m, d };
    };

    const jianchuCycle = ["å»º", "é™¤", "æ»¡", "å¹³", "å®š", "æ‰§", "ç ´", "å±", "æˆ", "æ”¶", "å¼€", "é—­"];
    const base = new Date("2024-01-01T00:00:00Z"); // ç®€æ˜“å¾ªç¯åŸºå‡†

    const controls = document.createElement("div");
    controls.className = "calendar-controls";
    const prevBtn = document.createElement("button");
    prevBtn.type = "button";
    prevBtn.innerText = "ï¼œ";
    const todayBtn = document.createElement("button");
    todayBtn.type = "button";
    todayBtn.innerText = "ä»Š";
    const nextBtn = document.createElement("button");
    nextBtn.type = "button";
    nextBtn.innerText = "ï¼";
    controls.appendChild(prevBtn);
    controls.appendChild(todayBtn);
    controls.appendChild(nextBtn);

    const header = document.createElement("div");
    header.className = "calendar-header";
    const headerMain = document.createElement("div");
    headerMain.className = "calendar-header-main";
    const headerSub = document.createElement("div");
    headerSub.className = "calendar-header-sub";
    const headerTerm = document.createElement("div");
    headerTerm.className = "calendar-header-term";
    const headerTermList = document.createElement("div");
    headerTermList.className = "calendar-header-term-list";
    header.appendChild(headerMain);
    header.appendChild(headerSub);
    header.appendChild(headerTerm);
    header.appendChild(headerTermList);

    const grid = document.createElement("div");
    grid.className = "calendar-grid";

    container.appendChild(header);
    container.appendChild(controls);
    container.appendChild(grid);

    function getTermForDay(termsMap, month, day) {
      const terms = termsMap[month] || [];
      const found = terms.find((t) => t.d === day);
      return found ? found.n : "";
    }

    function updateHeader(date) {
      const y = date.getFullYear();
      const m = date.getMonth() + 1;
      const d = date.getDate();
      const diff = Math.floor((date - base) / 86400000);
      const jianchu = jianchuCycle[((diff % 12) + 12) % 12];
      const slogan = jianchuSlogans[jianchu] ? ` Â· ${jianchuSlogans[jianchu]}` : "";
      headerMain.innerText = `${y}å¹´${m}æœˆ${d}æ—¥${slogan}`;

      const { y: ly, m: lm, d: ld } = getLunarParts(date);
      const lunarGZ = `${ganzhiYear(ly)}${ganzhiMonth(ly, lm)}${ganzhiDay(date)}`;
      const lunarText = `${lunarGZ}ï¼ˆ${toChineseYear(ly)}å¹´ï¼‰ ${lunarMonthName(lm)}${lunarDayName(ld)}`;
      headerSub.innerText = lunarText;
      const termsMap = computeSolarTerms(y);
      const term = getTermForDay(termsMap, m, d);
      if (term) {
        headerTerm.innerText = `èŠ‚æ°”ï¼š${term}`;
      }
    }

    function getTermDiffs(date) {
      const y = date.getFullYear();
      const termsThisYear = computeSolarTerms(y);
      const termsNextYear = computeSolarTerms(y + 1);
      const todayMid = new Date(y, date.getMonth(), date.getDate()).getTime();

      const collect = (map, year) =>
        Object.entries(map).flatMap(([m, arr]) =>
          arr.map((t) => ({
            name: t.n,
            date: new Date(year, Number(m) - 1, t.d).getTime(),
          }))
        );
      const allTerms = [...collect(termsThisYear, y), ...collect(termsNextYear, y + 1)].sort((a, b) => a.date - b.date);
      const next = allTerms.find((t) => t.date >= todayMid) || allTerms[0];
      const second = allTerms.find((t) => t.date > (next ? next.date : todayMid)) || next;

      const withDiff = (item) =>
        item
          ? {
              name: item.name,
              diff: Math.round((item.date - todayMid) / 86400000),
            }
          : null;

      return {
        next: withDiff(next),
        next2: withDiff(second),
      };
    }

    function updateTermList(date) {
      // æœˆå†…åˆ—è¡¨ä¸å†å›ºå®šå±•ç¤º
      headerTermList.innerText = "";

      const diffs = getTermDiffs(date);
      if (diffs.next) {
        const nextText = `èŠ‚æ°”ï¼š${diffs.next.name}ï¼ˆ${diffs.next.diff === 0 ? "ä»Šå¤©" : `è¿˜æœ‰${diffs.next.diff}å¤©`}ï¼‰`;
        const next2Text =
          diffs.next2 && diffs.next2.name !== diffs.next.name
            ? ` / ä¸‹ä¸€èŠ‚æ°”ï¼š${diffs.next2.name}ï¼ˆ${diffs.next2.diff === 0 ? "ä»Šå¤©" : `è¿˜æœ‰${diffs.next2.diff}å¤©`}ï¼‰`
            : "";
        headerTerm.innerText = `${nextText}${next2Text}`;
      } else {
        headerTerm.innerText = "";
      }
    }

    function renderGrid() {
      grid.innerHTML = "";
      const view = new Date(state.viewDate);
      const year = view.getFullYear();
      const start = new Date(year, view.getMonth(), 1);
      const end = new Date(year, view.getMonth() + 1, 0);
      const startWeekday = start.getDay();
      const daysInMonth = end.getDate();
      const termsMap = computeSolarTerms(year);

      const weekdays = ["æ—¥", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­"];
      weekdays.forEach((d) => {
        const el = document.createElement("div");
        el.className = "calendar-cell calendar-weekday";
        el.innerText = d;
        grid.appendChild(el);
      });

      for (let i = 0; i < startWeekday; i++) {
        const blank = document.createElement("div");
        blank.className = "calendar-cell calendar-empty";
        grid.appendChild(blank);
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(view.getFullYear(), view.getMonth(), day);
        const cell = document.createElement("div");
        cell.className = "calendar-cell calendar-day";

        const isToday = date.getTime() === today.getTime();
        const isSelected = date.getTime() === state.selectedDate.getTime();
        if (isToday) cell.classList.add("calendar-today");
        if (isSelected) cell.classList.add("calendar-selected");

        const g = document.createElement("div");
        g.className = "calendar-greg";
        g.innerText = day;

        const lunarParts = lunarDayFormatter.formatToParts(date);
        const lunarDayNum = parseLunarNumber(lunarParts.find((p) => p.type === "day")?.value || 0);
        const lunar = document.createElement("div");
        lunar.className = "calendar-lunar";
        lunar.innerText = lunarDayName(lunarDayNum);

        const diff = Math.floor((date - base) / 86400000);
        const jianchu = jianchuCycle[((diff % 12) + 12) % 12];
        const jc = document.createElement("div");
        jc.className = "calendar-jianchu";
        jc.innerText = jianchu;

        const termName = getTermForDay(termsMap, view.getMonth() + 1, day);
        if (termName) {
          const term = document.createElement("div");
          term.className = "calendar-term-dot";
          term.title = termName;
          cell.appendChild(term);
        }

        cell.appendChild(g);
        cell.appendChild(lunar);
        cell.appendChild(jc);

        cell.addEventListener("click", () => {
          state.selectedDate = date;
          updateHeader(date);
          renderGrid();
          updateTermList(date);
        });

        cell.addEventListener("mouseenter", () => {
          if (termName) {
            headerTerm.innerText = `èŠ‚æ°”ï¼š${termName}`;
          }
        });
        cell.addEventListener("mouseleave", () => {
          const selectedTerm = getTermForDay(
            state.selectedDate.getMonth() + 1,
            state.selectedDate.getDate()
          );
          headerTerm.innerText = selectedTerm ? `èŠ‚æ°”ï¼š${selectedTerm}` : "";
        });

        grid.appendChild(cell);
      }

      updateHeader(state.selectedDate);
    }

    prevBtn.onclick = () => {
      state.viewDate = new Date(state.viewDate.getFullYear(), state.viewDate.getMonth() - 1, 1);
      renderGrid();
      updateTermList(state.selectedDate);
    };
    nextBtn.onclick = () => {
      state.viewDate = new Date(state.viewDate.getFullYear(), state.viewDate.getMonth() + 1, 1);
      renderGrid();
      updateTermList(state.selectedDate);
    };
    todayBtn.onclick = () => {
      const now = new Date();
      state.viewDate = new Date(now.getFullYear(), now.getMonth(), 1);
      state.selectedDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      renderGrid();
      updateTermList(state.selectedDate);
    };

    renderGrid();
    updateTermList(state.selectedDate);
  })();
</script>

